[{"authors":["admin"],"categories":null,"content":"Born in San José, Costa Rica in 1989, César Gamboa is a Statistician graduated from the School of Statistics of University of Costa Rica. Professor of Probability and Statistics, in addition to programming in the R language, he is also a demographic researcher dedicated to the use of algorithms for optimization and analysis by through computer simulations.\nRecognized for his capacity for statistical analysis, software and programming languages management for data analysis such as R, Python, and Git. Versatile for the automation of processes through specialized algorithms, analytical and mathematical capacity and the ability for self-taught learning.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/en/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/en/authors/admin/","section":"authors","summary":"Born in San José, Costa Rica in 1989, César Gamboa is a Statistician graduated from the School of Statistics of University of Costa Rica. Professor of Probability and Statistics, in addition to programming in the R language, he is also a demographic researcher dedicated to the use of algorithms for optimization and analysis by through computer simulations.\nRecognized for his capacity for statistical analysis, software and programming languages management for data analysis such as R, Python, and Git.","tags":null,"title":"César Gamboa Sanabria","type":"authors"},{"authors":[],"categories":null,"content":"","date":1595264400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595264400,"objectID":"ce85074e3122813948e4b9e506d3050e","permalink":"/en/talk/cursor202007/","publishdate":"2019-12-05T17:00:00Z","relpermalink":"/en/talk/cursor202007/","section":"talk","summary":"This course consists of sixteen hours, divided into four sessions of four hours each. The purpose of the course is to provide the student with the starting point to use the R programming language. By using this language, the student can read and create data, manipulate objects, generate different types of data visualization, and obtain basic statistics.","tags":[],"title":"R Programming","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["R basics"],"content":"\reapply function\rUsing environments\rIn R, an Environment is a site to assign variables or values that we assign to objects. Each time a new R session begins, all created objects stay in the global environment. If we create the object x, it will then be in the R default Environment. Thels() function lists the created objects, so we can check that x actually exists.\nx \u0026lt;- 28022020\rls()\r## [1] \u0026quot;x\u0026quot;\rIt is possible to assign the global Environment to an object that we’ll call environment_1. The curious thing is that after doing this, environment_1 is an object into the global Environment , but at the same time, it is the global Environmet.\nenvironment_1 \u0026lt;- globalenv()\rclass(environment_1)\r## [1] \u0026quot;environment\u0026quot;\rls()\r## [1] \u0026quot;environment_1\u0026quot; \u0026quot;x\u0026quot;\rThis process is similar to using a list, a topic that we talked about in this post. Since the object environment_1 is the global environment, it contains the objectx, which we assign to the global Environment and also includes itself in a cyclical way…\nenvironment_1$x\r## [1] 28022020\renvironment_1$environment_1\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\renvironment_1$environment_1$environment_1\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\rls(environment_1$environment_1$environment_1$environment_1)\r## [1] \u0026quot;environment_1\u0026quot; \u0026quot;x\u0026quot;\rThe environment_1 object could, as Emmett Brown someday said, it creates a paradox that would destroy the universe, so it is best to eliminate it. Section 2.1.10 of the R language definition offers a more formal description of what a Environment  is.\nrm(environment_1)\rls()\r## [1] \u0026quot;x\u0026quot;\rIt is possible to create a new Environment that is independent of the global Environment, which we will call environment_2. When creating it, we can see that it is empty compared to the global Environment, which contains x and environment_2. Also, if we directly generate a new variable, say z, it will set to the global  Environment.\nenvironment_2 \u0026lt;- new.env()\renvironment_2\r## \u0026lt;environment: 0x0000000013231bb8\u0026gt;\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot;\rls(environment_2)\r## character(0)\rz \u0026lt;- pi\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## character(0)\rNow we create a new object called yand we assign it to environment_2. Now, the object y will be contain only in environment_2 and not in Environment global, even if the last one contains environment_2.\nenvironment_2$y \u0026lt;- \u0026quot;This is an abstract topic\u0026quot;\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## [1] \u0026quot;y\u0026quot;\renvironment(x)\r## NULL\rHas an Environment a real use? The answer is yes, and they are fundamental in something widely used in R: Functions. In general, when building a function, it is assumed that it has only two components: the arguments and the content of the function. Consider a simple function that reverses the sign of a number.\nreverse_sign \u0026lt;- function(number){\rnumber*-1\r}\rIn the previous case, the reverse_sign() function has a single argument number, while its content is \\(number\\cdot -1\\). However, the functions have a third argument: Environment. When the reverse_sign() function created, it was in the global Environment.\nls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;reverse_sign\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## [1] \u0026quot;y\u0026quot;\renvironment(reverse_sign)\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\rThe consequence is that the reverse_sign() function only works in the Environment assigned to it. For example, the function run only on the object x that is in the global Environment:\nreverse_sign(x)\r## [1] -28022020\rIf we create an object that is also called x, but that is in theenvironment_2, the reverse_sign() function still running only in the global Environment.\nenvironment_2$x \u0026lt;- 123456\rreverse_sign(x)\r## [1] -28022020\r\reapply function\rThese small details that we usually don’t handle in regular tasks using R may become indispensable in certain situations, such as when you want to use the eapply() function. Knowing basics on how an Environment works, we are going to eliminate all the objects created so far, this to keep everything in order.\nrm(list = ls())\rAs we also review in this post, the lapply() function applies a function to each element of a list. Similarly, the eapply() function applies a function to each element named in an Environment with the difference that in eaaply(), the first argument is an Environment, and not a list as in lapply(). Let’s create now a new Environment to apply a function to its elements that return the square root of each one plus 10:\nenvironment_1 \u0026lt;- new.env()\renvironment_1$element_1 \u0026lt;- 4\renvironment_1$element_2 \u0026lt;- 9\renvironment_1$element_3 \u0026lt;- 25\reapply(environment_1, function(x){\rsqrt(x)+10\r})\r## $element_1\r## [1] 12\r## ## $element_2\r## [1] 13\r## ## $element_3\r## [1] 15\rWe can also display the result without name tags:\neapply(environment_1, function(x){\rsqrt(x)+10\r}, USE.NAMES = FALSE)\r## [[1]]\r## [1] 12\r## ## [[2]]\r## [1] 13\r## ## [[3]]\r## [1] 15\rPrevious runs of the eapply() function evaluate our function in all the elements contained in the Environment, but there are exceptions if there are hidden elements. The hidden elements are objects that exist but are not visible to the naked eye, we can create the element_4 as hidden as follows:\nenvironment_1$.element_4 \u0026lt;- 48\rls(environment_1)\r## [1] \u0026quot;element_1\u0026quot; \u0026quot;element_2\u0026quot; \u0026quot;element_3\u0026quot;\rIf we repeat the previous evaluation of the eapply() function, it only runs with the visible elements:\neapply(environment_1, function(x){\rsqrt(x)+10\r})\r## $element_1\r## [1] 12\r## ## $element_2\r## [1] 13\r## ## $element_3\r## [1] 15\rBut we can run that function over all elements:\neapply(environment_1, function(x){\rsqrt(x)+10\r}, all.names = TRUE)\r## $element_1\r## [1] 12\r## ## $.element_4\r## [1] 16.9282\r## ## $element_2\r## [1] 13\r## ## $element_3\r## [1] 15\r\r\rrapply function\rIn this function, the “r” refers to “recursive”. This function has two objectives: Apply a function recursively to a list or apply that function only to the elements of a list with a specific class. This second reason is especially useful because the lists in R are perhaps the most useful objects when we are using that language because they store databases, numbers, character strings, graphics, and more. We can apply a function to every numeric element of a list, without the need to know in which positions these elements are within the list. A simple example can be applied to the famous iris data set:\nrapply(iris, mean, class=\u0026quot;numeric\u0026quot;)\r## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333\rrapply(iris, table, class=\u0026quot;factor\u0026quot;)\r## Species.setosa Species.versicolor Species.virginica ## 50 50 50\rOr, if we have a list with different classes, we may want to multiply by two those elements of the list that are numerical:\nrapply(list(2,5,7,\u0026quot;We can\u0026#39;t multiply this element because is a string\u0026quot;), function(x){x*2}, class=\u0026quot;numeric\u0026quot;)\r## [1] 4 10 14\r\rmapply function\rThe mapply() function can be seen as the multivariate version of the apply functions. For example, lapply() function can only be applied to the elements of a list, but if you have a list whose elements are an argument of a function and another list whose elements are the other argument of the function, then mapply() is used. The function to be applied must have as many arguments as the number of lists to pass to mapply(). MoreArgs argument is useful if there are more arguments that need to use in the function. It is easier to show its operation with an example than with words. Suppose we want to obtain the result of \\(x*y+1\\) by varying the values of \\(x\\) and \\(y\\) as follows: \\(1\\cdot 2 + 1, 2\\cdot 3 + 1, 3\\cdot 4 + 1, \\cdots , 10000\\cdot 10001 + 1\\). We can obtain this calculation through a for loop as follows:\nz \u0026lt;- NULL\rk \u0026lt;- 1\rx \u0026lt;- 1:10000\ry \u0026lt;- 2:10001\rfor(i in 1:10000){\rz[k] \u0026lt;- x[i]*y[i]+1\rk \u0026lt;- k+1\r}\rBut we can also use the mapply() function:\nmapply(function(x,y){x*y+1},\rx=1:10000,\ry=2:10001)\rBoth functions display the same result; however, mapply() is considerably more efficient when performing the calculation. We will compare the running time of different processes in the next post when I’ll show you some parallel versions of the apply family functions.\n\r","date":1583110557,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583110557,"objectID":"42b1e4f4eb804ff278d33147826cefac","permalink":"/en/post/2020-03-01-eapply_rapply_mapply/","publishdate":"2020-03-01T18:55:57-06:00","relpermalink":"/en/post/2020-03-01-eapply_rapply_mapply/","section":"post","summary":"The eapply(), rapply() and mapply() functions in data analysis.","tags":["R","RStudio","apply functions","eapply","rapply","mapply"],"title":"apply family functions - Part 4","type":"post"},{"authors":[],"categories":null,"content":"","date":1580230800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580230800,"objectID":"2e34d83274df9ffdcda028217aefdcaa","permalink":"/en/talk/cursor202001/","publishdate":"2019-12-05T17:00:00Z","relpermalink":"/en/talk/cursor202001/","section":"talk","summary":"This course consists of sixteen hours, divided into four sessions of four hours each. The purpose of the course is to provide the student with the starting point to use the R programming language. By using this language, the student can read and create data, manipulate objects, generate different types of data visualization, and obtain basic statistics.","tags":[],"title":"R Programming","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["R basics"],"content":"\rIn this new post about the apply family functions, we’ll show some examples of three new functions: lapply(), sapply(), and vapply(). These functions generally works with objects of class list; however, other variants can work with vectors.\nSuppose now we have several databases on which we need to obtain the sum of each column. We’ll generate a simple function that returns a database of random numbers in the range $ [1,100] $ and also contains missing values, with a certain number of rows and columns.\ndat \u0026lt;- function(rows, columns){\rvalues \u0026lt;- sample(x = c(NA,1:100), size = rows*columns,\rreplace = TRUE)\ras.data.frame(matrix(data = values,\rnrow = rows, ncol = columns))\r}\rThus, for example, we can generate a database with 50 rows and 5 columns by executing the following command:\nset.seed(20191208)\rdf1 \u0026lt;- dat(50, 5)\rLet’s generate more other databases of dimensions \\(100\\times5\\) and \\(150\\times5\\).\nset.seed(20191208)\rdf2 \u0026lt;- dat(100, 5)\rdf3 \u0026lt;- dat(150, 5)\rAs we saw in this post, we could use the apply() function to get the sum of the columns.\napply(df1,2,sum)\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482\rapply(df2,2,sum)\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177\rapply(df3,2,sum)\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rOr, something simpler would be to use the function colSums().\ncolSums(df1)\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482\rcolSums(df2)\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177\rcolSums(df3)\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rHowever, we could have a large number of databases, so the above procedures are not viable since writing so many lines of code is quite dull.\nThat’s the time the lists come into play. The three databases we generate can be stored in a single list as follows.\nlist1 \u0026lt;- list(df1, df2, df3)\rBy having a list, each database becomes an element of that list. For example, element 1 is the set df1, while the sets df2 and df3 are elements 2 and three, respectively. One way to call the elements within a list is by [[]], as follows we call the data set df2:\nlist1[[2]]\r## V1 V2 V3 V4 V5\r## 1 35 90 35 84 79\r## 2 51 36 4 100 5\r## 3 76 47 65 90 36\r## 4 17 22 97 72 1\r## 5 95 16 8 86 65\r## 6 73 31 47 52 87\r## 7 37 23 64 85 13\r## 8 81 62 33 82 27\r## 9 59 63 79 40 45\r## 10 38 25 34 9 24\r## 11 92 82 53 75 80\r## 12 94 51 50 35 87\r## 13 44 54 10 49 71\r## 14 96 23 54 62 99\r## 15 73 87 8 64 16\r## 16 58 94 67 41 100\r## 17 92 93 78 34 59\r## 18 30 64 53 49 80\r## 19 14 21 94 59 86\r## 20 14 9 51 42 19\r## 21 55 99 12 70 54\r## 22 30 34 93 76 68\r## 23 19 40 85 29 51\r## 24 46 83 98 41 88\r## 25 48 34 100 49 37\r## 26 29 34 72 11 62\r## 27 39 78 68 41 20\r## 28 68 62 51 68 76\r## 29 92 69 37 15 95\r## 30 15 25 63 72 24\r## 31 72 90 4 63 35\r## 32 7 34 91 95 5\r## 33 62 43 1 66 57\r## 34 32 69 29 87 30\r## 35 96 67 21 32 13\r## 36 13 71 26 96 91\r## 37 58 72 30 66 5\r## 38 80 45 84 45 86\r## 39 84 89 83 86 2\r## 40 44 78 13 6 23\r## 41 24 70 63 93 1\r## 42 22 65 32 85 40\r## 43 32 54 79 34 88\r## 44 10 12 37 31 21\r## 45 48 28 9 61 75\r## 46 19 95 22 71 41\r## 47 60 48 4 26 30\r## 48 79 34 59 80 65\r## 49 25 77 61 5 95\r## 50 69 7 71 75 60\r## 51 33 53 100 43 19\r## 52 16 82 9 98 52\r## 53 53 60 35 3 77\r## 54 9 31 33 61 72\r## 55 42 17 64 40 80\r## 56 71 87 95 31 72\r## 57 79 20 11 6 67\r## 58 67 55 57 55 31\r## 59 82 82 5 87 93\r## 60 84 34 20 22 9\r## 61 38 22 92 45 24\r## 62 48 75 60 5 74\r## 63 44 78 78 29 66\r## 64 10 70 14 37 16\r## 65 12 12 93 66 19\r## 66 88 29 63 94 30\r## 67 77 44 34 59 96\r## 68 5 46 81 11 72\r## 69 79 40 73 26 99\r## 70 96 24 46 94 7\r## 71 46 64 12 2 30\r## 72 3 38 50 89 85\r## 73 86 17 14 21 37\r## 74 57 37 NA 15 36\r## 75 23 12 48 20 46\r## 76 41 7 82 69 46\r## 77 59 5 4 93 98\r## 78 47 52 23 59 94\r## 79 19 47 58 12 47\r## 80 44 34 15 15 47\r## 81 15 38 57 84 67\r## 82 98 8 83 10 64\r## 83 50 38 48 95 40\r## 84 17 18 24 1 59\r## 85 73 12 2 30 48\r## 86 41 79 38 48 68\r## 87 12 84 77 25 79\r## 88 66 52 5 85 41\r## 89 80 39 60 29 29\r## 90 100 43 15 16 3\r## 91 9 37 75 52 94\r## 92 94 22 19 48 52\r## 93 53 9 100 83 52\r## 94 37 39 78 31 65\r## 95 96 26 66 87 22\r## 96 64 25 29 7 55\r## 97 62 50 91 21 45\r## 98 18 44 94 15 18\r## 99 61 11 48 48 50\r## 100 98 45 27 17 68\rNow, if we need to apply the colSums() function to each data set, we can use the lapply() function:\nlapply(list1, colSums)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rThe result is a list with the sum of the columns of each database. If we need to do the sums, but without counting the missing values, we have to incorporate the respective argument of the colSums() function.\nlapply(list1, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033\rAs you can see, the lapply() function works with three arguments: a list -in this case, the list object-, a function that we want to apply to each element of that list -in this case, colSums()-, and if necessary, the arguments requested by the indicated function -in this case na.rm = TRUE of the colSums()- function.\nThe previous result returns the calculations in an object of class list; however, in many cases, it is desirable to obtain a more orderly format. The sapply() function works identically to lapply(), with the proviso that if the result of each item in the list has the same length, the sapply() function groups the result. By using the lapply() motion, we obtain a list of three elements, where each element is a vector of length five, that is, they all have the same length, so the sapply() function would return the following:\nsapply(list1, colSums)\r## [,1] [,2] [,3]\r## V1 2546 5148 NA\r## V2 2602 4692 7554\r## V3 2699 NA NA\r## V4 1993 5024 NA\r## V5 2482 5177 NA\rsapply(list1, colSums, na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rAlthough the sapply() function seems more useful than lapply(), it has a small inconvenience, and it is always going to work… How can this be an inconvenience? Let’s incorporate a new data set, but this time with six columns instead of five like the previous ones.\ndf4 \u0026lt;- dat(150, 6)\rlist2 \u0026lt;- list(df1, df2, df3, df4)\rIf we use the lapply() function again, we would again obtain the sums by columns in the form of a list:\nlapply(list2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rWhile if we apply the sapply() function:\nsapply(list2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rNow we get a list, that is, the same result as with sapply(). The reason is that not all elements have the same length, before there were three vectors of length five, while now also a vector of length six. This fact seems to be irrelevant, since a result is still being obtained, however depending on the context that result will not always be valid.\nSuppose that based on the analysis we are doing, we know that the sum of the columns can only return a vector of length five and that if the result is something else, it may be due to an error in one of the databases, such as additional columns. The vapply() function allows us, like sapply(), to apply a function to the elements of a list, but specifying that the expected result, in this case, is a numerical vector of length five. Let’s first make a comparison between sapply() and vapply() with the object list, which has three databases with five columns:\nsapply(list1, colSums, na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rvapply(list1, colSums, numeric(5), na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rThe results are identical. But now let’s repeat the previous example but for the object list2, which contains a data set with six columns.\nsapply(list2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rThe sapply() function performs the calculation, but under the assumption that the expected result is vectors of length five, this result is incorrect. The vapply() function helps us control this problem.\nvapply(list2, colSums, numeric(5), na.rm=TRUE)\r## Error in vapply(list2, colSums, numeric(5), na.rm = TRUE): Los valores deben ser de longitud 5, ## pero el resultado FUN(X [[4]]) es la longitud 6\rWhen trying to execute the code, we get an error, since evaluating the function in element number four of the list returns a vector of length six and not five as expected.\nThe vapply() function is generally more advisable than sapply() because it allows you to have more control over the expected results.\n","date":1575852957,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575852957,"objectID":"da2e72f6ac88af8f8b99e73889922b04","permalink":"/en/post/2019-12-08-lapply_sapply_vapply/","publishdate":"2019-12-08T18:55:57-06:00","relpermalink":"/en/post/2019-12-08-lapply_sapply_vapply/","section":"post","summary":"The lapply(), sapply() and vapply() functions in data analysis.","tags":["R","RStudio","apply functions","lapply","sapply","vapply"],"title":"apply family functions - Part 3","type":"post"},{"authors":["César Gamboa Sanabria"],"categories":["R basics"],"content":"\rIn this second part of the post series on the apply family of functions, it is the tapply() function. Unlike the apply () function discussed in the first post, the tapply() function is often used to apply a function to subsets of a vector. Usually, when working with databases, there are variables of different nature, some can be numerical, others categorical, the idea of tapply() is to obtain summaries of a vector but being grouped concerning other vectors (variables).\nOn this occasion, we will use the starwars database seen in the post on the inspectdf package again.\nIf we need to know the average height of the characters, execute the following command.\nmean(starwars$height, na.rm = TRUE)\r## [1] 174.358\rHowever, it is more valuable to obtain the average height according to another variable of interest that allows us to make some comparison, such as gender. For this, we can use the tapply() function.\ntapply(X=starwars$height, INDEX=starwars$gender, FUN=mean) \r## female hermaphrodite male none ## NA 175 NA NA\rThe NA that appear are due to missing values within the database, so the mean() function does not calculate the average correctly unless an imputation of these missing values is made or indicated that the mean() function must omit the missing values using the argument na.rm = TRUE. In most of the apply family functions, the arguments that belong to the function being applied (in this case mean()) must go after the FUN argument.\ntapply(X=starwars$height, INDEX=starwars$gender,\rFUN=mean, na.rm=TRUE) \r## female hermaphrodite male none ## 165.4706 175.0000 179.2373 200.0000\rThe tapply() function is not limited to a single grouping variable. The same “dimensions” concept that we discuss in the apply () function can be used to tapply(), but this time the grouping variables must be specified within a list. As an example, suppose we are interested in the average height according to gender and eye color.\ntapply(X=starwars$height,\rINDEX=list(starwars$eye_color, starwars$gender), FUN=mean, na.rm=TRUE)\r## female hermaphrodite male none\r## black 195.5 NA 182.0000 NaN\r## blue 167.0 NA 189.2308 NA\r## blue-gray NA NA 182.0000 NA\r## brown 160.0 NA 168.5000 NA\r## dark NA NA NaN NA\r## gold NA NA 191.0000 NA\r## green, yellow NA NA 216.0000 NA\r## hazel 178.0 NA 170.0000 NA\r## orange NA 175 181.2857 NA\r## pink NA NA 180.0000 NA\r## red NA NA 190.5000 200\r## red, blue 96.0 NA NA NA\r## unknown NaN NA 136.0000 NA\r## white 178.0 NA NA NA\r## yellow 168.0 NA 180.1111 NA\rWe can add more grouping variables, but all of them must be within the list. For example, it is possible to grouping also by the skin color, although in this case, the result would show many missing values because not all combinations exist. That is a demonstration that each time we grouping variables, these groupings should make sense; otherwise, the analysis will not be useful.\ntapply(X=starwars$height,\rINDEX=list(starwars$eye_color, starwars$gender, starwars$skin_color), FUN=mean, na.rm=TRUE)\r## , , blue\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA 196 NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel 178 NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , blue, grey\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA 115.5 NA\r## ## , , brown\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA 234.0 NA\r## blue-gray NA NA NA NA\r## brown NA NA 129.5 NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA 198.0 NA\r## ## , , brown mottle\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 180 NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , brown, white\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA 216 NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , dark\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue 184 NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA 183.25 NA\r## dark NA NA NaN NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , fair\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue 158.5 NA 181.1250 NA\r## blue-gray NA NA 182.0000 NA\r## brown 163.0 NA 185.3333 NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA 170.0000 NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , fair, green, yellow\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow 168 NA NA NA\r## ## , , gold\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , green\r## ## female hermaphrodite male none\r## black NA NA 184.5 NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA 66.0 NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 206.0 NA\r## pink NA NA NA NA\r## red NA NA 190.0 NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA 183.0 NA\r## ## , , green-tan, brown\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA 175 NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , green, grey\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA 193 NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , grey\r## ## female hermaphrodite male none\r## black 213 NA 198.3333 NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA 191.0000 NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 224.0000 NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , grey, blue\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA 79 NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , grey, green, yellow\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 163 NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , grey, red\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 112 NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , light\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue 165.00 NA 176.5 NA\r## blue-gray NA NA NA NA\r## brown 159.25 NA 185.5 NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NaN NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , metal\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA 200\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , mottled green\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA 191 NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , none\r## ## female hermaphrodite male none\r## black NA NA NA NaN\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , orange\r## ## female hermaphrodite male none\r## black NA NA 188 NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 196 NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , pale\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA 188 NA\r## pink NA NA 180 NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white 178 NA NA NA\r## yellow NA NA 184 NA\r## ## , , red\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA 175 NA\r## ## , , red, blue, white\r## ## female hermaphrodite male none\r## black 178 NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , silver, red\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue 96 NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , tan\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA 187 NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , unknown\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA 228 NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NaN NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , white\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA 233 NA\r## ## , , white, blue\r## ## female hermaphrodite male none\r## black NA NA 122 NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , white, red\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue NA NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r## ## , , yellow\r## ## female hermaphrodite male none\r## black NA NA NA NA\r## blue 168 NA NA NA\r## blue-gray NA NA NA NA\r## brown NA NA NA NA\r## dark NA NA NA NA\r## gold NA NA NA NA\r## green, yellow NA NA NA NA\r## hazel NA NA NA NA\r## orange NA NA NA NA\r## pink NA NA NA NA\r## red NA NA NA NA\r## red, blue NA NA NA NA\r## unknown NA NA NA NA\r## white NA NA NA NA\r## yellow NA NA NA NA\r","date":1564620957,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564620957,"objectID":"550582a0f65965bbdafbc119409b7d46","permalink":"/en/post/2019-07-31-tapply/","publishdate":"2019-07-31T18:55:57-06:00","relpermalink":"/en/post/2019-07-31-tapply/","section":"post","summary":"The tapply function in data analysis.","tags":["R","RStudio","apply family functions","tapply"],"title":"Apply family functions - Part 2","type":"post"},{"authors":["César Gamboa Sanabria"],"categories":["R basics"],"content":"\rThe apply family functions belong to the R base package, they are especially useful when combining their use with functions to manipulate pieces of matrices, arrays, lists and data frames. These functions allow you to cross data in multiple ways to avoid the use of for loops that are usually computationally heavier.\nThe first function we will talk about in this series is the apply () function, which in its simplest form of use is used to evaluate the margins (1 = rows or 2 = columns) of a matrix or an array to apply a function to them.\nAs a first example, we start from a matrix with three rows and three columns.\nmat \u0026lt;- matrix(c(2, 4, 6, 7, 8, 9, 1, 12, 21), nrow = 3, ncol = 3)\rmat\r## [,1] [,2] [,3]\r## [1,] 2 7 1\r## [2,] 4 8 12\r## [3,] 6 9 21\rIf you wish, for example, to obtain the sum of each column, you can use the apply () function as follows.\napply(mat, 2, sum)\r## [1] 12 24 34\rWe can also calculate the average of each row.\napply(mat, 1, mean)\r## [1] 3.333333 8.000000 12.000000\rThere are also some functions already programmed in the R base package that quickly replicate the previous results. For example, there is the colSums () function to calculate the amount of each column, and rowMeans () to obtain the arithmetic mean of each row.\ncolSums(mat)\r## [1] 12 24 34\rrowMeans(mat)\r## [1] 3.333333 8.000000 12.000000\rThe two cases shown above exemplify a basic use of the apply () function, however, this function is much more powerful and is capable of working in a multidimensional way. Consider, for example, an object in two dimensions (rows and columns) similar to the one created previously, that is, an array.\nmat2 \u0026lt;- matrix(1:9, nrow = 3, ncol = 3)\rmat2\r## [,1] [,2] [,3]\r## [1,] 1 4 7\r## [2,] 2 5 8\r## [3,] 3 6 9\rThe mat2 object represents a particular case of an array, which can be created using thearray ()function.\narray(data=1:9, dim = c(3,3))\r## [,1] [,2] [,3]\r## [1,] 1 4 7\r## [2,] 2 5 8\r## [3,] 3 6 9\rThe array () function also allows you to add tags to the rows and columns using its dimnames argument.\nnombres.columnas \u0026lt;- c(\u0026quot;COL1\u0026quot;,\u0026quot;COL2\u0026quot;,\u0026quot;COL3\u0026quot;)\rnombres.filas \u0026lt;- c(\u0026quot;FILA1\u0026quot;,\u0026quot;FILA2\u0026quot;,\u0026quot;FILA3\u0026quot;)\rarreglo \u0026lt;- array(data=1:9, dim = c(3,3), dimnames = list(nombres.columnas, nombres.filas))\rarreglo\r## FILA1 FILA2 FILA3\r## COL1 1 4 7\r## COL2 2 5 8\r## COL3 3 6 9\rWe can add multiple dimensions to an array. For this, suppose you want to have the following sizes:\n\rDIM1: Numbers from 1 to 9.\rDIM2: Numbers from 1 to 9 multiplied by 10.\rDIM3: Numbers from 1 to 9 multiplied by 100.\rDIM4: Numbers from 1 to 9 increased by 1000.\r\rOne way to generate the previous arrangement is by using the following code:\nnombres.dimensiones \u0026lt;- c(\u0026quot;DIM1\u0026quot;,\u0026quot;DIM2\u0026quot;,\u0026quot;DIM3\u0026quot;,\u0026quot;DIM4\u0026quot;)\rarreglo \u0026lt;- array(data = c(seq(from=1, to=9, by=1), #1 al 9\rseq(from=10, to=90, by=10), #10 al 90\rseq(from=100, to=900, by=100), #100 al 900\rseq(from=1000, to=9000, by=1000)), #1000 al 9000\rdim = c(3, 3, 4), #3 filas, 3 columnas y 4 dimensiones\rdimnames = list(nombres.filas,\rnombres.columnas,\rnombres.dimensiones))\rarreglo\r## , , DIM1\r## ## COL1 COL2 COL3\r## FILA1 1 4 7\r## FILA2 2 5 8\r## FILA3 3 6 9\r## ## , , DIM2\r## ## COL1 COL2 COL3\r## FILA1 10 40 70\r## FILA2 20 50 80\r## FILA3 30 60 90\r## ## , , DIM3\r## ## COL1 COL2 COL3\r## FILA1 100 400 700\r## FILA2 200 500 800\r## FILA3 300 600 900\r## ## , , DIM4\r## ## COL1 COL2 COL3\r## FILA1 1000 4000 7000\r## FILA2 2000 5000 8000\r## FILA3 3000 6000 9000\rStarting from the previous array, suppose that you want to obtain the maximum value per row from each dimension.\napply(arreglo, c(3,1), max)\r## FILA1 FILA2 FILA3\r## DIM1 7 8 9\r## DIM2 70 80 90\r## DIM3 700 800 900\r## DIM4 7000 8000 9000\rOr, you may want to obtain the maximum value of each column from each dimension.\napply(arreglo, c(3,2), max)\r## COL1 COL2 COL3\r## DIM1 3 6 9\r## DIM2 30 60 90\r## DIM3 300 600 900\r## DIM4 3000 6000 9000\rThe following result shows the minimum of each column in each dimension.\napply(arreglo, c(2,3), min)\r## DIM1 DIM2 DIM3 DIM4\r## COL1 1 10 100 1000\r## COL2 4 40 400 4000\r## COL3 7 70 700 7000\rThe previous examples can be applied to arrays with a higher dimension; for this, it is enough to have an adequate arrangement and operate on the corresponding margins with the apply () function.\n","date":1563752529,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563752529,"objectID":"efeebc86a8281ce829d5fdf2cc289855","permalink":"/en/post/2019-06-23-apply/","publishdate":"2019-07-21T17:42:09-06:00","relpermalink":"/en/post/2019-06-23-apply/","section":"post","summary":"The apply function to multidimensional data.","tags":["R","RStudio","apply family functions","apply"],"title":"Apply family functions - Part 1","type":"post"},{"authors":[],"categories":null,"content":"","date":1563296400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563296400,"objectID":"00b35e0c03be0db2559b7f397190efd9","permalink":"/en/talk/cursor201906/","publishdate":"2019-07-16T17:00:00Z","relpermalink":"/en/talk/cursor201906/","section":"talk","summary":"This course consists of sixteen hours, divided into four sessions of four hours each. The purpose of the course is to provide the student with the starting point to use the R programming language. By using this language, the student can read and create data, manipulate objects, generate different types of data visualization, and obtain basic statistics.","tags":[],"title":"R Programming","type":"talk"},{"authors":[],"categories":null,"content":"","date":1561629600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1561629600,"objectID":"5a3f2b7f0342293c5b7d091e1ba8ebd3","permalink":"/en/talk/conversatorior/","publishdate":"2019-06-23T00:00:00Z","relpermalink":"/en/talk/conversatorior/","section":"talk","summary":"The School of Statistics is pleased to invite you to the following talks and free workshops that will be taught by Ing Ruiz de R Studio Inc from June 24 to 27, 2019.","tags":[],"title":"R as a tool of statistical analysis","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["Exploratory data analysis"],"content":"\rIt is a common task to find datasets which have different types of variables, and they could be numeric, time data, or even categorical. The inspectdf package offers a set of functions to analyze the behavior of this kind of data.\nFirst of all, we have to install the package.\nlibrary(devtools)\rinstall_github(\u0026quot;alastairrushworth/inspectdf\u0026quot;)\rWhen we installed the package, it is necessary to load it. We do the same with dplyr package, especially for use the pipe %\u0026gt;%.\nlibrary(inspectdf)\rlibrary(dplyr)\rFor this example, the dataset starwars will be used. This dataset is in dplyr package and which has data from various characters in this cinematographic universe.\nstarwars %\u0026gt;% head()\r## # A tibble: 6 x 13\r## name height mass hair_color skin_color eye_color birth_year gender\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 Luke~ 172 77 blond fair blue 19 male ## 2 C-3PO 167 75 \u0026lt;NA\u0026gt; gold yellow 112 \u0026lt;NA\u0026gt; ## 3 R2-D2 96 32 \u0026lt;NA\u0026gt; white, bl~ red 33 \u0026lt;NA\u0026gt; ## 4 Dart~ 202 136 none white yellow 41.9 male ## 5 Leia~ 150 49 brown light brown 19 female\r## 6 Owen~ 178 120 brown, gr~ light blue 52 male ## # ... with 5 more variables: homeworld \u0026lt;chr\u0026gt;, species \u0026lt;chr\u0026gt;, films \u0026lt;list\u0026gt;,\r## # vehicles \u0026lt;list\u0026gt;, starships \u0026lt;list\u0026gt;\rTabular exploratory data analysis\rThe inspectdf package allows you to calculate some descriptive statistics quickly for any variable using theinspect_types()function.\nstarwars %\u0026gt;% inspect_types()\r## # A tibble: 4 x 4\r## type cnt pcnt col_name ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;list\u0026gt; ## 1 character 7 53.8 \u0026lt;chr [7]\u0026gt;\r## 2 list 3 23.1 \u0026lt;chr [3]\u0026gt;\r## 3 numeric 2 15.4 \u0026lt;chr [2]\u0026gt;\r## 4 integer 1 7.69 \u0026lt;chr [1]\u0026gt;\rThe previous result shows that there are seven variables of type character, which represents 53.84% of the dataset. Also, there are two numerical variables, which represent 15.38%. The above is useful for a first look, but it is interesting to go a little further and describe all the variables in more detail. For this, the inspect_cat () function could be useful.\nstarwars %\u0026gt;% inspect_cat()\r## # A tibble: 7 x 5\r## col_name cnt common common_pcnt levels ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;list\u0026gt; ## 1 eye_color 15 brown 24.1 \u0026lt;tibble [15 x 3]\u0026gt;\r## 2 gender 5 male 71.3 \u0026lt;tibble [5 x 3]\u0026gt; ## 3 hair_color 13 none 42.5 \u0026lt;tibble [13 x 3]\u0026gt;\r## 4 homeworld 49 Naboo 12.6 \u0026lt;tibble [49 x 3]\u0026gt;\r## 5 name 87 Ackbar 1.15 \u0026lt;tibble [87 x 3]\u0026gt;\r## 6 skin_color 31 fair 19.5 \u0026lt;tibble [31 x 3]\u0026gt;\r## 7 species 38 Human 40.2 \u0026lt;tibble [38 x 3]\u0026gt;\rThe inspect_cat () function shows in the first column the name of the variable, in the second one the number of unique values it contains, that is, the variable * eye_color * has 15 different levels, or what is the same, there are 15 colors and different eyes in the database. The third column shows the most common value that appears in the variable; for example, the most common species that appear in the dataset are humans. The fourth column indicates the percentage that represents the most common level; for example, the brown eyes represent 24.13% of all the colors present in the data. So what does the fifth column represent? Well, it is a list with the proportions of each level of the variable. Consider the * df * object from the previous result.\ndf \u0026lt;- starwars %\u0026gt;% inspect_cat()\rdf$levels$eye_color\r## # A tibble: 15 x 3\r## value prop cnt\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 brown 0.241 21\r## 2 blue 0.218 19\r## 3 yellow 0.126 11\r## 4 black 0.115 10\r## 5 orange 0.0920 8\r## 6 red 0.0575 5\r## 7 hazel 0.0345 3\r## 8 unknown 0.0345 3\r## 9 blue-gray 0.0115 1\r## 10 dark 0.0115 1\r## 11 gold 0.0115 1\r## 12 green, yellow 0.0115 1\r## 13 pink 0.0115 1\r## 14 red, blue 0.0115 1\r## 15 white 0.0115 1\rThe table above shows the proportion of each eye color. The same applies to any of the other variables.\n\rGraphical exploratory data analysis\rSometimes the numerical values are not easy to interpret it, either due to a quantity of data or due to visual issues. The inspectdf package also graphically allows for exploratory data analysis.\ndf %\u0026gt;% show_plot()\rThe previous result contains the same information as the df object, but now it is easier, faster, and even easier to interpret. However, this result can be improved, because the variable * name * does not work much in the graph because all the names are different. It can solve by modifying the argument high_cardinality, which means that only those categories that appear a certain number of times say four will be in the plot.\ndf %\u0026gt;% show_plot(high_cardinality = 4)\rFinally, if the colors are not entirely pleasant, they can be manipulated through the five color palettes offered by the package, we only have to modify the col_palette argument with numbers between one and five to achieve this.\ndf %\u0026gt;% show_plot(high_cardinality = 4, col_palette = 4)\rdf %\u0026gt;% show_plot(high_cardinality = 4, col_palette = 5)\r\r","date":1561318929,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1561318929,"objectID":"510550bc8ea3cd0c8be33b7eaa853538","permalink":"/en/post/2019-06-23-exploraci%C3%B3n-de-datos-categ%C3%B3ricos-con-el-paquete-inspectdf/","publishdate":"2019-06-23T13:42:09-06:00","relpermalink":"/en/post/2019-06-23-exploraci%C3%B3n-de-datos-categ%C3%B3ricos-con-el-paquete-inspectdf/","section":"post","summary":"This post follows to show how to use the inspectdf package for data analysis","tags":["R","RStudio","Exploratory data analysis","Descriptive","Categorical data"],"title":"Exploratory data analysis with categorical data","type":"post"},{"authors":null,"categories":null,"content":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.\n","date":1462510131,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1462510131,"objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"/en/about/","publishdate":"2016-05-05T21:48:51-07:00","relpermalink":"/en/about/","section":"","summary":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.","tags":null,"title":"About","type":"page"}]