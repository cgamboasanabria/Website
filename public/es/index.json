[{"authors":["admin"],"categories":null,"content":"Nacido en San José, Costa Rica en 1989, César Gamboa es un Estadístico egresado de la Escuela de Estadística de la Universidad de Costa Rica. Profesor universitario de Probabilidad y Estadística, además de programación en el lenguaje R, es también un investigador de temas demográficos dedicado a la utilización de algoritmos para la optimización de procesos y el análisis por medio de simulaciones computacionales.\nReconocido por su capacidad de análisis estadístico, manejo de distintos software y lenguajes de programación para análisis de datos como R, Python, Git, o Unix. Versatil para la automatización de procesos mediante algoritmos especializados, capacidad analítica y matemática y gran facilidad para el aprendizaje de forma autodidacta.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"es","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/es/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/es/authors/admin/","section":"authors","summary":"Nacido en San José, Costa Rica en 1989, César Gamboa es un Estadístico egresado de la Escuela de Estadística de la Universidad de Costa Rica. Profesor universitario de Probabilidad y Estadística, además de programación en el lenguaje R, es también un investigador de temas demográficos dedicado a la utilización de algoritmos para la optimización de procesos y el análisis por medio de simulaciones computacionales.\nReconocido por su capacidad de análisis estadístico, manejo de distintos software y lenguajes de programación para análisis de datos como R, Python, Git, o Unix.","tags":null,"title":"César Gamboa Sanabria","type":"authors"},{"authors":[],"categories":null,"content":"","date":1595264400,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1595264400,"objectID":"ce85074e3122813948e4b9e506d3050e","permalink":"/es/talk/cursor202007/","publishdate":"2019-12-05T17:00:00Z","relpermalink":"/es/talk/cursor202007/","section":"talk","summary":"Este curso se compone de dieciséis horas distribuidas en cuatro sesiones de cuatro horas cada una.  El propósito del curso es proporcionar al estudiante un punto de partida para comenzar a utilizar de forma básica el lenguaje de programación R. Mediante el uso de este lenguaje el estudiante podrá leer y crear datos, manipular objetos, generar distintos tipos de visualización de datos y obtener estadísticos básicos. Más información al correo electrónico [uses.ee@ucr.ac.cr](uses.ee@ucr.ac.cr).","tags":[],"title":"Programación estadística en R","type":"talk"},{"authors":[],"categories":null,"content":"","date":1593709200,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1593709200,"objectID":"c89f217f553c4d5f54f48e0ff5748d4d","permalink":"/es/talk/dcur/","publishdate":"2020-05-24T17:00:00Z","relpermalink":"/es/talk/dcur/","section":"talk","summary":"Expertos nacionales e internacionales impartirán un ciclo de cinco videoconferencias sobre reducción de la dimensionalidad en matrices de datos, que expondrá con casos reales las últimas técnicas estadísticas relacionadas con la reducción de la dimensionalidad en matrices de datos, así como los algoritmos y paquetes estadísticos que existen para su utilización.","tags":[],"title":"Reducción de la dimensionalidad en matrices de datos","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["Fundamentos de R"],"content":"\r\rFunción eapply\rUso de Environments\rEn pocas palabras, en R un Environment es un sitio para almacenar variables, o valores que asignamos a objetos. Cada vez que se inicia una nueva sesión de R, todos los objetos creados se añadirán al Environment global. Si creamos el objeto x, este quedará entonces en el Environment predeterminado de R, la función ls() sirve para listar los objetos creados y en este caso comprobar que x existe.\nx \u0026lt;- 28022020\rls()\r## [1] \u0026quot;x\u0026quot;\rEs posible asignar el Environment global a un objeto, digamos environment_1. Una cosa curiosa es que tras hacer esto, environment_1 es un objeto que está en el Environmet global, pero al mismo tiempo es el Environmet global.\nenvironment_1 \u0026lt;- globalenv()\rclass(environment_1)\r## [1] \u0026quot;environment\u0026quot;\rls()\r## [1] \u0026quot;environment_1\u0026quot; \u0026quot;x\u0026quot;\rEste caso podría interpretarse como usar una lista, tema que ya fue discutido en este post. Como el objeto environment_1 es el ambiente global, contiene al objeto x, que fue asignado al Environment global; y también se contiene a sí mismo de una manera algo cíclica…\nenvironment_1$x\r## [1] 28022020\renvironment_1$environment_1\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\renvironment_1$environment_1$environment_1\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\rls(environment_1$environment_1$environment_1$environment_1)\r## [1] \u0026quot;environment_1\u0026quot; \u0026quot;x\u0026quot;\rEl objeto environment_1 podría, en palabras del buen docto Emmett Brown, crear una paradoja que destruiría el universo, así que lo mejor es eliminarlo. La sección 2.1.10 de la definición del lenguaje R ofrece una descripción más formal de lo que es un Environment.\nrm(environment_1)\rls()\r## [1] \u0026quot;x\u0026quot;\rEs posible crear un Environment nuevo que sea independiente del Environment global, la cual llamaremos environment_2. Al crearlo, podemos ver que este se encuentra vacío en comparación al Environment global, el cual contiene a x y a environment_2. Además, si generamos directamente una nueva variable, digamos z, esta se asignará al Environment global.\nenvironment_2 \u0026lt;- new.env()\renvironment_2\r## \u0026lt;environment: 0x000000001164e7a8\u0026gt;\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot;\rls(environment_2)\r## character(0)\rz \u0026lt;- pi\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## character(0)\rAhora crearemos una variable llamada y y se la asignaremos al environment_2. Tras hacer eso, la variable y estará contenida únicamente en el environment_2 y no en el Environment global, a pesar de que este último contiene al environment_2.\nenvironment_2$y \u0026lt;- \u0026quot;Esto es muy abstracto\u0026quot;\rls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## [1] \u0026quot;y\u0026quot;\renvironment(x)\r## NULL\r¿Los Environment sirven para algo más aparte de filosofar? La respuesta es que sí, y son fundamentales en algo muy utilizado en R: Las funciones. Por lo general, al construir una función se asume tiene únicamente dos componentes: los argumentos y el contenido de la función. Consideremos una sencilla función que invierte el signo de un número.\ninvertir_signo \u0026lt;- function(numero){\rnumero*-1\r}\rEn el caso anterior, la función invertir_signo() numero tiene un único argumento, mientras que su contenido es \\(numero\\cdot -1\\). Sin embargo, las funciones cuentan con un tercer argumento: El Environment. Cuando la función invertir_signo() fue creada, quedó almacenada en el Environment global.\nls(globalenv())\r## [1] \u0026quot;environment_2\u0026quot; \u0026quot;invertir_signo\u0026quot; \u0026quot;x\u0026quot; \u0026quot;z\u0026quot;\rls(environment_2)\r## [1] \u0026quot;y\u0026quot;\renvironment(invertir_signo)\r## \u0026lt;environment: R_GlobalEnv\u0026gt;\rLa consecuencia de esto es que la función invertir_signo() únicamente podrá ser evaluada en el Environment que tiene asignado. Por ejemplo, la función puede ser evaluada sobre el objeto x, que está en el environment global:\ninvertir_signo(x)\r## [1] -28022020\rSi creamos un objeto que también se llame x, pero que se encuentre en el environment_2, la función invertir_signo() seguirá siendo evaluada en el Environment global.\nenvironment_2$x \u0026lt;- 123456\rinvertir_signo(x)\r## [1] -28022020\r\rLa función eapply\rEstos pequeños detalles que no suelen manejarse en la vida diaria pueden llegar a ser indispensables en ciertas situaciones, como cuando se quiere utilizar la función eapply(). Connociendo los aspectos más elementales de cómo trabajan los Environment, vamos a eliminar todos los objetos creados hasta ahora, esto para mantener el orden.\nrm(list = ls())\rComo también repasamos en este post, la función lapply() aplica una función a cada elemento de una lista. De forma similar, la función eapply() aplica una función a cada elemento nombrado en un Environment con la diferencia que en eaaply() el primer argumento es un Environment, y no una lista como en lapply(). vamos a crear entonces un nuevo Environment para aplicarle una función a sus elemntos que devuelva la raíz cuadrada de cada uno y sumarle 10:\nenvironment_1 \u0026lt;- new.env()\renvironment_1$elemento_1 \u0026lt;- 4\renvironment_1$elemento_2 \u0026lt;- 9\renvironment_1$elemento_3 \u0026lt;- 25\reapply(environment_1, function(x){\rsqrt(x)+10\r})\r## $elemento_1\r## [1] 12\r## ## $elemento_2\r## [1] 13\r## ## $elemento_3\r## [1] 15\rEl resultado puede solicitarse sin las etiquetas de los nombres:\neapply(environment_1, function(x){\rsqrt(x)+10\r}, USE.NAMES = FALSE)\r## [[1]]\r## [1] 12\r## ## [[2]]\r## [1] 13\r## ## [[3]]\r## [1] 15\rLas anteriores ejecuciones de la función eapply() evalúan nuestra función en todos los elemntos que contenga el Environment, pero hay excepciones si se tienen elementos ocultos. Los elementos ocultos son objetos que existen pero que no están a simple vista, podems crear el elemento_4 como oculto de la siguiente manera:\nenvironment_1$.elemento_4 \u0026lt;- 48\rls(environment_1)\r## [1] \u0026quot;elemento_1\u0026quot; \u0026quot;elemento_2\u0026quot; \u0026quot;elemento_3\u0026quot;\rSi repetimos la evaluación anterior de la función eaaply(), se ejecutará solamente con los elementos visibles:\neapply(environment_1, function(x){\rsqrt(x)+10\r})\r## $elemento_1\r## [1] 12\r## ## $elemento_2\r## [1] 13\r## ## $elemento_3\r## [1] 15\rPero podemos pedir que se ejecute sobre todos los elementos:\neapply(environment_1, function(x){\rsqrt(x)+10\r}, all.names = TRUE)\r## $.elemento_4\r## [1] 16.9282\r## ## $elemento_1\r## [1] 12\r## ## $elemento_2\r## [1] 13\r## ## $elemento_3\r## [1] 15\r\r\rFunción rapply\rEn esta función, la “r” hace referencia a “recursivo”. Podría decirse que tiene dos objetivos: Aplicar una función de manera recursiva a una lista o aplicar dicha función a solo los elementos de una lista con una clase específica. Esto de especial utilidad, pues como ya lo hemos discutido, las listas en R son quizás los objetos más útiles que hay, pues de manera muy sencilla almacenan bases de datos, números, cadenas de caracteres, gráficos, y más, por lo que resulta útil aplicar una función a, digamos, todos los elementos numéricos de una lista, sin la necesidad de conocer en qué posiciones se encuentran dichos elementos dentro de la lista. Un ejemplo sencillo se puede aplicar al famoso conjunto de datos iris:\nrapply(iris, mean, class=\u0026quot;numeric\u0026quot;)\r## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333\rrapply(iris, table, class=\u0026quot;factor\u0026quot;)\r## Species.setosa Species.versicolor Species.virginica ## 50 50 50\rO bien, si tenemos una lista con distintas clases de objetos, podemos pedir que nos multiplique por dos aquellos elementos de la lista que son numéricos:\nrapply(list(2,5,7,\u0026quot;Esto no se puede multiplicar porque es una cadena de caracteres\u0026quot;), function(x){x*2}, class=\u0026quot;numeric\u0026quot;)\r## [1] 4 10 14\r\rFunción mapply\rLa función mapply() puede verse como la versión multivariada de las funciones apply.Por ejemplo, con lapply() solo puede aplicarse la función a los elementos de una lista, pero si se tiene una lista cuyos elementos son un argumento de una función y otra lista a cuyos elementos son el otro argumento de la función, entonces se usa mapply(). La función que se va a aplicar debe tener un número de argumentos al menos igual al número de listas que se van a pasar a mapply. MoreArgs sirve en caso de que se tengan más argumentos que se necesiten pasar a la función. Resulta más sencillo mostrar su funcionamiento con un ejemplo que con palabras. Supongamos que queremos obtener el resultado de \\(x*y+1\\) variando los valores de \\(x\\) e \\(y\\) de la siguiente manera: \\(1\\cdot2+1,2\\cdot3+1,3\\cdot4+1,\\cdots,10000\\cdot10001+1\\). La forma de obtener este cálculo mediante un ciclo for es la siguiente:\nz \u0026lt;- NULL\rk \u0026lt;- 1\rx \u0026lt;- 1:10000\ry \u0026lt;- 2:10001\rfor(i in 1:10000){\rz[k] \u0026lt;- x[i]*y[i]+1\rk \u0026lt;- k+1\r}\rMientras que con la función mapply() se obtiene así:\nmapply(function(x,y){x*y+1},\rx=1:10000,\ry=2:10001)\rAmbas llegan al mismo resultado, sin embargo, mapply() es considerablemente más eficiente al realizar el cálculo. Compararemos los tiempos de ejecución de distintos procesos en el siguiente post, donde se mostrarán algunas versiones en paralelo de las funciones apply.\n\r","date":1583110557,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1583110557,"objectID":"42b1e4f4eb804ff278d33147826cefac","permalink":"/es/post/2020-03-01-eapply_rapply_mapply/","publishdate":"2020-03-01T18:55:57-06:00","relpermalink":"/es/post/2020-03-01-eapply_rapply_mapply/","section":"post","summary":"Se muestran ejemplos de uso de las funciones eapply(), rapply() y mapply()","tags":["R","RStudio","Funciones apply","eapply","rapply","mapply"],"title":"Familia de funciones apply - Parte 4","type":"post"},{"authors":[],"categories":null,"content":"","date":1580230800,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1580230800,"objectID":"2e34d83274df9ffdcda028217aefdcaa","permalink":"/es/talk/cursor202001/","publishdate":"2019-12-05T17:00:00Z","relpermalink":"/es/talk/cursor202001/","section":"talk","summary":"Este curso se compone de dieciséis horas distribuidas en cuatro sesiones de cuatro horas cada una.  El propósito del curso es proporcionar al estudiante un punto de partida para comenzar a utilizar de forma básica el lenguaje de programación R. Mediante el uso de este lenguaje el estudiante podrá leer y crear datos, manipular objetos, generar distintos tipos de visualización de datos y obtener estadísticos básicos.","tags":[],"title":"Programación estadística en R","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["Fundamentos de R"],"content":"\r\rEn este nuevo post sobre la familia de funciones apply, es momento de mostrar algunos ejemplos de uso sobre tres nuevas funciones: lapply(), sapply() y vapply(). Las tres funciones están pensadas para trabajar con objetos de clase list, sin embargo, otras variantes pueden trabajarse con vectores.\nSupongamos que tenemos varias bases de datos sobre las cuales necesitamos obtener la suma de las columnas. Vamos primero a generar una sencilla función que nos devuelva una base de datos de números aleatorios del intervalo \\([1,100]\\) y que además contenga valores faltantes, con un determinado número de filas y columnas.\ndatos \u0026lt;- function(filas, columnas){\rvalores \u0026lt;- sample(x = c(NA,1:100), size = filas*columnas,\rreplace = TRUE)\ras.data.frame(matrix(data = valores,\rnrow = filas, ncol = columnas))\r}\rAsí, por ejemplo, podemos generar una base de datos con 50 filas y 5 columnas ejecutando el siguiente comando:\nset.seed(20191208)\rdf1 \u0026lt;- datos(50, 5)\rGeneremos otras dos bases de datos de dimensiones \\(100\\times5\\) y \\(150\\times5\\).\nset.seed(20191208)\rdf2 \u0026lt;- datos(100, 5)\rdf3 \u0026lt;- datos(150, 5)\rComo vimos en este post, podríamos utilizar la función apply() para obtener la suma de las columnas.\napply(df1,2,sum)\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482\rapply(df2,2,sum)\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177\rapply(df3,2,sum)\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rO bien, algo más sencillo sería utilizar la función colSums().\ncolSums(df1)\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482\rcolSums(df2)\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177\rcolSums(df3)\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rSin embargo, podríamos tener una gran cantidad de bases datos, con lo cual los procedimientos anteriores no son viables, pues escribir tantas líneas de código es bastante aburrido…\nEs ahí donde entran en juego las listas. Las tres bases de datos que generamos podemos almacenarlas en una sola lista de la siguiente manera.\nlista \u0026lt;- list(df1, df2, df3)\rAl tener una lista, cada base de datos se convierte en un elemento de esa lista. Por ejemplo, el elemento 1 de esa lista es el conjunto df1, mientras que los conjuntos df2 y df3 son los elementos 2 y tres respectivamente. Una forma de llamar a los elementos dentro de una lista es mediante [[]], de la siguiente manera llamamos al conjunto de datos df2:\nlista[[2]]\r## V1 V2 V3 V4 V5\r## 1 35 90 35 84 79\r## 2 51 36 4 100 5\r## 3 76 47 65 90 36\r## 4 17 22 97 72 1\r## 5 95 16 8 86 65\r## 6 73 31 47 52 87\r## 7 37 23 64 85 13\r## 8 81 62 33 82 27\r## 9 59 63 79 40 45\r## 10 38 25 34 9 24\r## 11 92 82 53 75 80\r## 12 94 51 50 35 87\r## 13 44 54 10 49 71\r## 14 96 23 54 62 99\r## 15 73 87 8 64 16\r## 16 58 94 67 41 100\r## 17 92 93 78 34 59\r## 18 30 64 53 49 80\r## 19 14 21 94 59 86\r## 20 14 9 51 42 19\r## 21 55 99 12 70 54\r## 22 30 34 93 76 68\r## 23 19 40 85 29 51\r## 24 46 83 98 41 88\r## 25 48 34 100 49 37\r## 26 29 34 72 11 62\r## 27 39 78 68 41 20\r## 28 68 62 51 68 76\r## 29 92 69 37 15 95\r## 30 15 25 63 72 24\r## 31 72 90 4 63 35\r## 32 7 34 91 95 5\r## 33 62 43 1 66 57\r## 34 32 69 29 87 30\r## 35 96 67 21 32 13\r## 36 13 71 26 96 91\r## 37 58 72 30 66 5\r## 38 80 45 84 45 86\r## 39 84 89 83 86 2\r## 40 44 78 13 6 23\r## 41 24 70 63 93 1\r## 42 22 65 32 85 40\r## 43 32 54 79 34 88\r## 44 10 12 37 31 21\r## 45 48 28 9 61 75\r## 46 19 95 22 71 41\r## 47 60 48 4 26 30\r## 48 79 34 59 80 65\r## 49 25 77 61 5 95\r## 50 69 7 71 75 60\r## 51 33 53 100 43 19\r## 52 16 82 9 98 52\r## 53 53 60 35 3 77\r## 54 9 31 33 61 72\r## 55 42 17 64 40 80\r## 56 71 87 95 31 72\r## 57 79 20 11 6 67\r## 58 67 55 57 55 31\r## 59 82 82 5 87 93\r## 60 84 34 20 22 9\r## 61 38 22 92 45 24\r## 62 48 75 60 5 74\r## 63 44 78 78 29 66\r## 64 10 70 14 37 16\r## 65 12 12 93 66 19\r## 66 88 29 63 94 30\r## 67 77 44 34 59 96\r## 68 5 46 81 11 72\r## 69 79 40 73 26 99\r## 70 96 24 46 94 7\r## 71 46 64 12 2 30\r## 72 3 38 50 89 85\r## 73 86 17 14 21 37\r## 74 57 37 NA 15 36\r## 75 23 12 48 20 46\r## 76 41 7 82 69 46\r## 77 59 5 4 93 98\r## 78 47 52 23 59 94\r## 79 19 47 58 12 47\r## 80 44 34 15 15 47\r## 81 15 38 57 84 67\r## 82 98 8 83 10 64\r## 83 50 38 48 95 40\r## 84 17 18 24 1 59\r## 85 73 12 2 30 48\r## 86 41 79 38 48 68\r## 87 12 84 77 25 79\r## 88 66 52 5 85 41\r## 89 80 39 60 29 29\r## 90 100 43 15 16 3\r## 91 9 37 75 52 94\r## 92 94 22 19 48 52\r## 93 53 9 100 83 52\r## 94 37 39 78 31 65\r## 95 96 26 66 87 22\r## 96 64 25 29 7 55\r## 97 62 50 91 21 45\r## 98 18 44 94 15 18\r## 99 61 11 48 48 50\r## 100 98 45 27 17 68\rAhora, si quisiéramos aplicar la función colSums() a cada conjunto de datos, podemos utilizar la función lapply():\nlapply(lista, colSums)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 NA 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## NA 7554 NA NA NA\rEl resultado es una lista con la suma de las columnas de cada base de datos. Si quisiéramos realizar las sumas pero sin contar los valores faltantes, solo hay que incorporar el argumento respectivo de la función colSums().\nlapply(lista, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033\rComo puede notarse, la función lapply() trabaja básicamente con tres argumentos: una lista (en este caso el objeto lista), una función que deseamos aplicarle a cada elemento de esa lista (en este caso colSums()), y de ser necesario, los argumentos que solicitados por la función in dicada (en este caso na.rm=TRUE de la función colSums()).\nEl resultado anterior devuelve los cálculos en un objeto de clase list, sin embargo, en muchas ocasiones es deseable obtener un formato algo más ordenado. la función sapply() trabaja de forma idéntica a lapply(), con la salvedad de que si el resultado de cada elemento de la lista posee la misma longitud, la función sapply() agrupa el resultado. Al utilizar la sunción lapply() obtenemos una lista de tres elementos, donde cada elemento es un vector de longitud cinco, es decir, todos tienen la misma longitud, por lo que la función sapply() devolvería lo siguiente:\nsapply(lista, colSums)\r## [,1] [,2] [,3]\r## V1 2546 5148 NA\r## V2 2602 4692 7554\r## V3 2699 NA NA\r## V4 1993 5024 NA\r## V5 2482 5177 NA\rsapply(lista, colSums, na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rAunque la función sapply() parezca más útil que lapply(), tiene un pequeño inconveniente, y es que siempre va a funcionar… ¿Cómo puede esto ser un inconveniente? Incorporemos un nuevo conjunto de datos, pero esta vez con seis columnas en lugar de cinco como los anteriores.\ndf4 \u0026lt;- datos(150, 6)\rlista2 \u0026lt;- list(df1, df2, df3, df4)\rSi utilizamos nuevamente la función lapply(), obtendríamos de nuevo las sumas por columnas en forma de una lista:\nlapply(lista2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rMientras que si aplicamos la función sapply():\nsapply(lista2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rAhora obtenemos una lista, es decir, el mismo resultado que con sapply(). Esto sucede porque ahora no todos los elementos tienen la misma longitud, antes se tenían tres vectores de longitud cinco, mientras que ahora también se tiene un vector de longitud seis. Esto parece ser algo sin importancia, pues igual se está obteniendo un resultado, sin embargo dependiendo del contexto ese resultado no siempre será válido.\nSupongamos que basados en el análisis que estamos realizando, sabemos que la suma de las columnas solamente puede devolver un vector de longitud cinco, y que si el resultado es otra cosa puede deberse a un error en alguna de las bases de datos, como columnas adicionales. La función vapply() nos permite, al igual que sapply(), aplicar una función a los elementos de una lista, pero especificando que el resultado esperado, en este caso, es un vector numérico de longitud cinco. Hagamos primero una comparación entre sapply() y vapply() con el objeto lista, que tiene tres bases de datos con cinco columnas:\nsapply(lista, colSums, na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rvapply(lista, colSums, numeric(5), na.rm=TRUE)\r## [,1] [,2] [,3]\r## V1 2546 5148 7780\r## V2 2602 4692 7554\r## V3 2699 4887 7470\r## V4 1993 5024 7826\r## V5 2482 5177 7033\rLos resultados son idénticos. Pero ahora repitamos el ejemplo anterior pero para el objeto lista2, que contiene un conjunto de datos con seis columnas.\nsapply(lista2, colSums, na.rm=TRUE)\r## [[1]]\r## V1 V2 V3 V4 V5 ## 2546 2602 2699 1993 2482 ## ## [[2]]\r## V1 V2 V3 V4 V5 ## 5148 4692 4887 5024 5177 ## ## [[3]]\r## V1 V2 V3 V4 V5 ## 7780 7554 7470 7826 7033 ## ## [[4]]\r## V1 V2 V3 V4 V5 V6 ## 8205 6712 6794 8049 7562 7335\rLa función sapply() realiza el cálculo, pero bajo el supuesto de que el resultado esperado son vectores de longitud cinco, este resultado es incorrecto. La función vapply() nos ayuda a controlar esto:\nvapply(lista2, colSums, numeric(5), na.rm=TRUE)\r## Error in vapply(lista2, colSums, numeric(5), na.rm = TRUE): Los valores deben ser de longitud 5, ## pero el resultado FUN(X [[4]]) es la longitud 6\rAl intentar ejecutar el código obtenemos un error, pues evaluar la función en el elemento número cuatro de la lista hace que se obtenga un vector de longitud seis, y no de cinco como esperábamos. Utilizar vapply() es, generalmente, más recomendable que sapply() pues permite tener un mayor control sobre los resultados esperados.\n","date":1575852957,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1575852957,"objectID":"da2e72f6ac88af8f8b99e73889922b04","permalink":"/es/post/2019-12-08-lapply_sapply_vapply/","publishdate":"2019-12-08T18:55:57-06:00","relpermalink":"/es/post/2019-12-08-lapply_sapply_vapply/","section":"post","summary":"Se muestran ejemplos de uso de las funciones lapply(), sapply() y vapply()","tags":["R","RStudio","Funciones apply","lapply","sapply","vapply"],"title":"Familia de funciones apply - Parte 3","type":"post"},{"authors":["César Gamboa Sanabria"],"categories":["Fundamentos de R"],"content":"\r\rEn esta segunda parte de la serie de post sobre la familia de funciones apply le toca el turno la función tapply(). A diferencia de la función apply() tratada en el primer post, la función tapply() se usa frecuentemente para aplicar una función a subconjuntos de un vector. Normalmente, al trabajar con bases de datos, se cuenta con variables de distinta naturaleza, algunas pueden ser numéricas, otras categóricas, la idea de tapply() es obtener resúmenes de un vector pero siendo agrupado en relación a otros vectores (variables).\nEn esta ocasión utilizaremos e nuevo la base de datos de starwars vista en el post sobre el paquete inspectdf.\nSi quisiéramos saber la altura promedio de los personajes, basta con ejecutar el siguiente comando.\nmean(starwars$height, na.rm = TRUE)\r## [1] 174.358\rSin embargo, es más valioso obtener la altura promedio de acuerdo con otra variable de interés que nos permita hacer alguna comparación, como por ejemplo el género. Para esto podemos utilizar la función tapply().\ntapply(X=starwars$height, #Variable de interés\rINDEX=starwars$gender, #Variable de agrupamiento\rFUN=mean) #Función a aplicar\r## feminine masculine ## NA NA\rLos NA que aparecen se deben a que existen valores faltantes dentro de la base de datos, por lo cual la función mean() no calcula correctamente el promedio a menos que se realice una imputación de estos valores faltantes o bien se indique que la función mean() debe omitir los valores faltantes usando el argumento na.rm=TRUE. En la mayoría de las funciones de la familia apply, los argumentos que pertenecen a al función que se está aplicando (en este caso mean()) deben ir después del argumento FUN.\ntapply(X=starwars$height, #Variable de interés\rINDEX=starwars$gender, #Variable de agrupamiento\rFUN=mean, #Función a aplicar\rna.rm=TRUE) #Se omiten los NA\r## feminine masculine ## 164.6875 176.5161\rLa función tapply() no está limitada a una única variable de agrupamiento. El mismo concepto de “dimensiones” que aplicamos en la función apply() puede ser aplicado a tapply(), pero en esta ocasión las variables de agrupamiento deben especificarse dentro de una lista. A modo de ejemplo, supongamos que nos interesa saber la altura promedio según el género y el color de ojos.\ntapply(X=starwars$height,\rINDEX=list(starwars$eye_color, starwars$gender), FUN=mean, na.rm=TRUE)\r## feminine masculine\r## black 195.5 182.0000\r## blue 167.0 189.7500\r## blue-gray NA 182.0000\r## brown 160.0 167.3846\r## dark NA NaN\r## gold NA 191.0000\r## green, yellow NA 216.0000\r## hazel 178.0 170.0000\r## orange NA 180.5000\r## pink NA 180.0000\r## red NA 154.8000\r## red, blue 96.0 NA\r## unknown NA 136.0000\r## white NA NA\r## yellow 168.0 178.8000\rSi se desea pueden agregarse más variables de agrupamiento, pero todas deben ser dentro de la lista. Por ejemplo, podría ser de interés agrupar también por el color de piel de los personajes, aunque en este caso el resultado mostraría muchos valores faltantes pues no todas las combinaciones existen. Esto es una demostración de que cada vez que se agrupen variables, estos agrupamientos deben tener sentido, pues de lo contrario solo se añadiría ruido al análisis.\ntapply(X=starwars$height,\rINDEX=list(starwars$eye_color, starwars$gender, starwars$skin_color), FUN=mean, na.rm=TRUE)\r## , , blue\r## ## feminine masculine\r## black NA NA\r## blue NA 196\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel 178 NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , blue, grey\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 115.5\r## ## , , brown\r## ## feminine masculine\r## black NA NA\r## blue NA 234.0\r## blue-gray NA NA\r## brown NA 129.5\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 198.0\r## ## , , brown mottle\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 180\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , brown, white\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA 216\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , dark\r## ## feminine masculine\r## black NA NA\r## blue 184 NA\r## blue-gray NA NA\r## brown NA 183.3333\r## dark NA NaN\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , fair\r## ## feminine masculine\r## black NA NA\r## blue 158.5 180.8571\r## blue-gray NA 182.0000\r## brown 163.0 185.3333\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA 170.0000\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , fair, green, yellow\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow 168 NA\r## ## , , gold\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 167\r## ## , , green\r## ## feminine masculine\r## black NA 184.5\r## blue NA NA\r## blue-gray NA NA\r## brown NA 66.0\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 206.0\r## pink NA NA\r## red NA 190.0\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 183.0\r## ## , , green-tan, brown\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 175\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , green, grey\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA 193\r## white NA NA\r## yellow NA NA\r## ## , , grey\r## ## feminine masculine\r## black 213 198.3333\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA 191.0000\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 224.0000\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , grey, blue\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA 79\r## white NA NA\r## yellow NA NA\r## ## , , grey, green, yellow\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 163\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , grey, red\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 112\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , light\r## ## feminine masculine\r## black NA NA\r## blue 165.00 176.5\r## blue-gray NA NA\r## brown 159.25 185.5\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NaN NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , metal\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA 200\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , mottled green\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA 191\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , none\r## ## feminine masculine\r## black NA NaN\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , orange\r## ## feminine masculine\r## black NA 188\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 196\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , pale\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA 188\r## pink NA 180\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 184\r## ## , , red\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 175\r## ## , , red, blue, white\r## ## feminine masculine\r## black 178 NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , silver, red\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue 96 NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , tan\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA 187\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , unknown\r## ## feminine masculine\r## black NA NA\r## blue NA 228\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , white\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA 233\r## ## , , white, blue\r## ## feminine masculine\r## black NA 122\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA 96\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , white, red\r## ## feminine masculine\r## black NA NA\r## blue NA NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA 97\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r## ## , , yellow\r## ## feminine masculine\r## black NA NA\r## blue 168 NA\r## blue-gray NA NA\r## brown NA NA\r## dark NA NA\r## gold NA NA\r## green, yellow NA NA\r## hazel NA NA\r## orange NA NA\r## pink NA NA\r## red NA NA\r## red, blue NA NA\r## unknown NA NA\r## white NA NA\r## yellow NA NA\r","date":1564620957,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1564620957,"objectID":"550582a0f65965bbdafbc119409b7d46","permalink":"/es/post/2019-07-31-tapply/","publishdate":"2019-07-31T18:55:57-06:00","relpermalink":"/es/post/2019-07-31-tapply/","section":"post","summary":"Se muestran ejemplos de uso de la función tapply()","tags":["R","RStudio","Funciones apply","tapply"],"title":"Familia de funciones apply - Parte 2","type":"post"},{"authors":["César Gamboa Sanabria"],"categories":["Fundamentos de R"],"content":"\r\rLa familia de funciones apply pertenecen al paquete base de R, son de especial utilidad al combinar su uso con funciones para manipular porciones de matrices, arreglos, listas y marcos de datos de una manera repetitiva. Estas funciones permiten cruzar los datos de múltiples maneras para así evadir el uso de ciclos que usualmente son computacionalmente más pesados.\nLa primera función de la que hablaremos en esta serie es la función apply(), la cual en su forma de utilización más sencilla se utiliza para evaluar sobre los márgenes (1=filas ó 2=columnas) de un arreglo o una matriz para aplicar una función a las mismas.\nComo primer ejemplo se parte de una matriz con tres filas y tres columnas.\nmat \u0026lt;- matrix(c(2, 4, 6, 7, 8, 9, 1, 12, 21), nrow = 3, ncol = 3)\rmat\r## [,1] [,2] [,3]\r## [1,] 2 7 1\r## [2,] 4 8 12\r## [3,] 6 9 21\rSi se desea, por ejemplo, obtener la suma de cada columna puede usarse la función apply() de la siguiente manera.\napply(mat, 2, sum)\r## [1] 12 24 34\rO bien, puede calcularse si se desea el promedio de cada una de las filas.\napply(mat, 1, mean)\r## [1] 3.333333 8.000000 12.000000\rExisten además algunas funciones ya programadas en el paquete base de R que replican rápidamente los resultados anteriores. Por ejemplo está la función colSums() para calcular la cuma de cada columna, y rowMeans() para obtener la media aritmética de cada fila.\ncolSums(mat)\r## [1] 12 24 34\rrowMeans(mat)\r## [1] 3.333333 8.000000 12.000000\rLos dos casos mostrados anteriormente ejemplifican un uso básico de la función apply(), sin embargo, esta función es mucho más potente y es capaz de trabajar de manera multidimensional. Consideremos, por ejemplo, un objeto en dos dimensiones (filas y columnas) similar al creado con anterioridad, es decir, una matriz.\nmat2 \u0026lt;- matrix(1:9, nrow = 3, ncol = 3)\rmat2\r## [,1] [,2] [,3]\r## [1,] 1 4 7\r## [2,] 2 5 8\r## [3,] 3 6 9\rEl objeto mat2 representa un caso particular de lo que en R se conoce como arreglos, los cuales pueden ser creados mediante la función array().\narray(data=1:9, dim = c(3,3))\r## [,1] [,2] [,3]\r## [1,] 1 4 7\r## [2,] 2 5 8\r## [3,] 3 6 9\rLa función array() también permite agregar etiquetas a las filas y las columnas mediante su argumento dimnames.\nnombres.columnas \u0026lt;- c(\u0026quot;COL1\u0026quot;,\u0026quot;COL2\u0026quot;,\u0026quot;COL3\u0026quot;)\rnombres.filas \u0026lt;- c(\u0026quot;FILA1\u0026quot;,\u0026quot;FILA2\u0026quot;,\u0026quot;FILA3\u0026quot;)\rarreglo \u0026lt;- array(data=1:9, dim = c(3,3), dimnames = list(nombres.columnas, nombres.filas))\rarreglo\r## FILA1 FILA2 FILA3\r## COL1 1 4 7\r## COL2 2 5 8\r## COL3 3 6 9\rPueden agregarse varias dimensiones a los arreglos. Para esto, supongamos que se desean tener las siguientes dimensiones:\n\rDIM1: Números del 1 al 9.\rDIM2: Números del 1 al 9 multiplicados por 10.\rDIM3: Números del 1 al 9 multiplicados por 100.\rDIM4: Números del 1 al 9 multiplicados por 1000.\r\rUna forma de generar el arreglo anterior es mediante el siguiente código:\nnombres.dimensiones \u0026lt;- c(\u0026quot;DIM1\u0026quot;,\u0026quot;DIM2\u0026quot;,\u0026quot;DIM3\u0026quot;,\u0026quot;DIM4\u0026quot;)\rarreglo \u0026lt;- array(data = c(seq(from=1, to=9, by=1), #1 al 9\rseq(from=10, to=90, by=10), #10 al 90\rseq(from=100, to=900, by=100), #100 al 900\rseq(from=1000, to=9000, by=1000)), #1000 al 9000\rdim = c(3, 3, 4), #3 filas, 3 columnas y 4 dimensiones\rdimnames = list(nombres.filas,\rnombres.columnas,\rnombres.dimensiones))\rarreglo\r## , , DIM1\r## ## COL1 COL2 COL3\r## FILA1 1 4 7\r## FILA2 2 5 8\r## FILA3 3 6 9\r## ## , , DIM2\r## ## COL1 COL2 COL3\r## FILA1 10 40 70\r## FILA2 20 50 80\r## FILA3 30 60 90\r## ## , , DIM3\r## ## COL1 COL2 COL3\r## FILA1 100 400 700\r## FILA2 200 500 800\r## FILA3 300 600 900\r## ## , , DIM4\r## ## COL1 COL2 COL3\r## FILA1 1000 4000 7000\r## FILA2 2000 5000 8000\r## FILA3 3000 6000 9000\rPartiendo del arreglo anterior, supongamos que se desea obtener de cada dimensión el valor máximo por filas.\napply(arreglo, c(3,1), max)\r## FILA1 FILA2 FILA3\r## DIM1 7 8 9\r## DIM2 70 80 90\r## DIM3 700 800 900\r## DIM4 7000 8000 9000\rO bien, quizás interese obtener de cada dimensión el valor máximo de cada columna.\napply(arreglo, c(3,2), max)\r## COL1 COL2 COL3\r## DIM1 3 6 9\r## DIM2 30 60 90\r## DIM3 300 600 900\r## DIM4 3000 6000 9000\rEl siguiente resultado muestra el mínimo de cada columna en cada dimensión.\napply(arreglo, c(2,3), min)\r## DIM1 DIM2 DIM3 DIM4\r## COL1 1 10 100 1000\r## COL2 4 40 400 4000\r## COL3 7 70 700 7000\rLos ejemplos anteriores pueden ser aplicados a un número mayor de dimensiones, para ello basta con tener un arreglo adecuado y operar sobre los márgenes correspondientes con la función apply().\n","date":1563752529,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1563752529,"objectID":"efeebc86a8281ce829d5fdf2cc289855","permalink":"/es/post/2019-06-23-apply/","publishdate":"2019-07-21T17:42:09-06:00","relpermalink":"/es/post/2019-06-23-apply/","section":"post","summary":"Se muestran ejemplos de uso de la función apply","tags":["R","RStudio","Funciones apply","apply"],"title":"Familia de funciones apply - Parte 1","type":"post"},{"authors":[],"categories":null,"content":"","date":1563296400,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1563296400,"objectID":"00b35e0c03be0db2559b7f397190efd9","permalink":"/es/talk/cursor201906/","publishdate":"2019-07-16T17:00:00Z","relpermalink":"/es/talk/cursor201906/","section":"talk","summary":"Este curso se compone de dieciséis horas distribuidas en cuatro sesiones de cuatro horas cada una.  El propósito del curso es proporcionar al estudiante un punto de partida para comenzar a utilizar de forma básica el lenguaje de programación R. Mediante el uso de este lenguaje el estudiante podrá leer y crear datos, manipular objetos, generar distintos tipos de visualización de datos y obtener estadísticos básicos.","tags":[],"title":"Programación estadística en R","type":"talk"},{"authors":[],"categories":null,"content":"","date":1561629600,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1561629600,"objectID":"5a3f2b7f0342293c5b7d091e1ba8ebd3","permalink":"/es/talk/conversatorior/","publishdate":"2019-06-23T00:00:00Z","relpermalink":"/es/talk/conversatorior/","section":"talk","summary":"La Escuela de Estadística tiene el agrado de invitarle a las siguientes charlas y talleres gratuitos que impartirá el Ing Ruiz de R Studio Inc del 24 al 27 de junio de 2019.","tags":[],"title":"Uso de R como herramienta de análisis estadístico","type":"talk"},{"authors":["César Gamboa Sanabria"],"categories":["Análisis exploratorio"],"content":"\r\rEs muy común en el día a día encontrarse con bases de datos que cuentan con diferentes tipos de variables, ya sean numéricas, temporales, de texto o categóricas. Estas últimas son el tema de discusión de este post. El paquete inspectdf ofrece un conjunto de funciones que resultan particularmente útiles cuando lo que se busca es explorar el comportamiento de este tipo de variables.\nEl primer paso es tener debidamente instalado el paquete inspectdf.\nlibrary(devtools)\rinstall_github(\u0026quot;alastairrushworth/inspectdf\u0026quot;)\rUna vez instalado es necesario cargarlo, así como cargar también el paquete dplyr, especialmente para poder usar el operador %\u0026gt;%.\nlibrary(inspectdf)\rlibrary(dplyr)\rPara este ejemplo se utilizará la base de datos starwars, la cual viene incluida en el paquete dplyr y que cuenta con datos de varios personajes de este universo cinematográfico.\nstarwars %\u0026gt;% head()\r## # A tibble: 6 x 14\r## name height mass hair_color skin_color eye_color birth_year sex gender\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 Luke~ 172 77 blond fair blue 19 male mascu~\r## 2 C-3PO 167 75 \u0026lt;NA\u0026gt; gold yellow 112 none mascu~\r## 3 R2-D2 96 32 \u0026lt;NA\u0026gt; white, bl~ red 33 none mascu~\r## 4 Dart~ 202 136 none white yellow 41.9 male mascu~\r## 5 Leia~ 150 49 brown light brown 19 fema~ femin~\r## 6 Owen~ 178 120 brown, gr~ light blue 52 male mascu~\r## # ... with 5 more variables: homeworld \u0026lt;chr\u0026gt;, species \u0026lt;chr\u0026gt;, films \u0026lt;list\u0026gt;,\r## # vehicles \u0026lt;list\u0026gt;, starships \u0026lt;list\u0026gt;\rAnálisis exploratorio de manera tabular\rEL paquete inspectdf permite calcular algunos estadísticos descriptivos rápidamente para cualquier tipo de variable mediante la función inspect_types().\nstarwars %\u0026gt;% inspect_types()\r## # A tibble: 4 x 4\r## type cnt pcnt col_name ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;named list\u0026gt;\r## 1 character 8 57.1 \u0026lt;chr [8]\u0026gt; ## 2 list 3 21.4 \u0026lt;chr [3]\u0026gt; ## 3 numeric 2 14.3 \u0026lt;chr [2]\u0026gt; ## 4 integer 1 7.14 \u0026lt;chr [1]\u0026gt;\rEl resultado anterior muestra que hay 7 variables de tipo character, lo cual representa el 53.84% de la base de datos. Además, hay dos variables de tipo numérico, que representa un 15.38% del total. Lo anterior es útil para un primer vistazo, pero resulta interesante ir un poco más allá y describir más en detalle todas las variables. Para esto puede usarse la función inspect_cat().\nstarwars %\u0026gt;% inspect_cat()\r## # A tibble: 8 x 5\r## col_name cnt common common_pcnt levels ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;named list\u0026gt; ## 1 eye_color 15 brown 24.1 \u0026lt;tibble [15 x 3]\u0026gt;\r## 2 gender 3 masculine 75.9 \u0026lt;tibble [3 x 3]\u0026gt; ## 3 hair_color 13 none 42.5 \u0026lt;tibble [13 x 3]\u0026gt;\r## 4 homeworld 49 Naboo 12.6 \u0026lt;tibble [49 x 3]\u0026gt;\r## 5 name 87 Ackbar 1.15 \u0026lt;tibble [87 x 3]\u0026gt;\r## 6 sex 5 male 69.0 \u0026lt;tibble [5 x 3]\u0026gt; ## 7 skin_color 31 fair 19.5 \u0026lt;tibble [31 x 3]\u0026gt;\r## 8 species 38 Human 40.2 \u0026lt;tibble [38 x 3]\u0026gt;\rLa función inspect_cat() muestra en la primera columna el nombre de la variable, en la segunda la cantidad de valores únicos que contiene, es decir, la variable eye_color tiene 15 niveles diferentes, o lo que es lo mismo, hay 15 colores e ojos diferentes en la base de datos. La tercera columna muestra el valor más común que aparece en la variable, por ejemplo, la especie más común que aparece en la base de datos son los humanos. La cuarta columna indica el porcentaje que representa el nivel más común, por ejemplo, los ojos color café representan el 24.13% de todos los colores presentes en los datos. ¿Y qué representa la quinta columna? Pues es una lista con las proporciones de cada nivel de la variable. Para ejemplificar esto último, se asignará al objeto df el resultado anterior.\ndf \u0026lt;- starwars %\u0026gt;% inspect_cat()\rdf$levels$eye_color\r## # A tibble: 15 x 3\r## value prop cnt\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 brown 0.241 21\r## 2 blue 0.218 19\r## 3 yellow 0.126 11\r## 4 black 0.115 10\r## 5 orange 0.0920 8\r## 6 red 0.0575 5\r## 7 hazel 0.0345 3\r## 8 unknown 0.0345 3\r## 9 blue-gray 0.0115 1\r## 10 dark 0.0115 1\r## 11 gold 0.0115 1\r## 12 green, yellow 0.0115 1\r## 13 pink 0.0115 1\r## 14 red, blue 0.0115 1\r## 15 white 0.0115 1\rLa tabla anterior muestra la proporción de cada color de ojos. Esto mismo se aplica a cualquiera de las otras variables.\n\rAnálisis exploratorio de manera gráfica\rEn algunas ocasiones los valores numéricos no sean tan claros ni fáciles de interpretar, ya sea por a cantidad de datos o bien por cuestiones de comodidad. El paquete inspectdf también permite hacer análisis exploratorio de manera gráfica\ndf %\u0026gt;% show_plot()\rEste resultado contiene la misma información que el objeto df, pero ahora es más fácil, rápido e incluso agradable para interpretar. Sin embargo, este resultado puede mejorar, pues por ejemplo la variable name no sirve de mucho en el gráfico porque todos los nombres son diferentes. Esto se puede solucionar modificando el argumento high_cardinality, lo cual hace que únicamente se grafiquen todas aquellas categorías que aparezcan un determinado número de veces, digamos cuatro.\ndf %\u0026gt;% show_plot(high_cardinality = 4)\rFinalmente, si los colores no resultan del todo agradables, pueden manipularse a voluntad mediante las 5 paletas de colores que ofrece el paquete y que e el futuro serán más, basta modificar el argumento col_palette con los números entre uno y cinco para lograr esto.\ndf %\u0026gt;% show_plot(high_cardinality = 4, col_palette = 4)\rdf %\u0026gt;% show_plot(high_cardinality = 4, col_palette = 5)\r\r","date":1561318929,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1561318929,"objectID":"510550bc8ea3cd0c8be33b7eaa853538","permalink":"/es/post/2019-06-23-exploraci%C3%B3n-de-datos-categ%C3%B3ricos-con-el-paquete-inspectdf/","publishdate":"2019-06-23T13:42:09-06:00","relpermalink":"/es/post/2019-06-23-exploraci%C3%B3n-de-datos-categ%C3%B3ricos-con-el-paquete-inspectdf/","section":"post","summary":"Este post presenta el paquete inspectdf como herramienta para el análisis exploratorio de datos categóricos","tags":["R","RStudio","Análisis exploratorio","Descripivos","Datos categóricos"],"title":"Análisis exploratorio de datos categóricos","type":"post"},{"authors":null,"categories":null,"content":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.\n","date":1462510131,"expirydate":-62135596800,"kind":"page","lang":"es","lastmod":1462510131,"objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"/es/about/","publishdate":"2016-05-05T21:48:51-07:00","relpermalink":"/es/about/","section":"","summary":"This is a \u0026ldquo;hello world\u0026rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.","tags":null,"title":"About","type":"page"}]